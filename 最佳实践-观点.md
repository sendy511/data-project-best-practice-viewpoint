### 1. 维度建模中，是否需要is_deleted字段

在维度建模中，会对维度表进行渐变，此时会有多余的一些列：

* zip_id。该表中全局唯一，相同的逻辑主键会对应不同的zip_id
* start_time。该数据的开始时间
* end_time。该数据的结束时间
* is_valid。代表当前数据的有效无效，可以理解为该逻辑主键的最后一条数据。通常，该数据和end_time冗余，当end_time为null时，is_valid为1。

在业务告知数据为**全量更新**时，如果出现数据的缺失，此时会有两种处理做法。如下为产品的更新场景。

<img src="/Users/xiaoqiangma/Library/Application Support/typora-user-images/image-20221101164704670.png" alt="image-20221101164704670" style="zoom:50%;" />

示例为某企业产品的全量更新场景，上图中，第二次更新时，C产品缺失，此时会有如下两种处理做法。

#### 使用is_deleted标识

第一种是使用is_deleted来标记全量更新中缺失的数据。

> 此时的产品表建模数据如下。
>
> <img src="/Users/xiaoqiangma/Library/Application Support/typora-user-images/image-20221101164845222.png" alt="image-20221101164845222" style="zoom:50%;" />

#### 不使用is_deleted标识，但融合业务含义

第二种是不使用is_deleted的标识。因为是全量更新，因此，缺失数据一定需要有对应的业务含义。如下为缺失数据的两种业务场景对应的数据。

> 1. 当业务告知，缺失数据视为和之前保持一致时，即，缺失数据是同步过程中丢失的，没有任何业务含义。此时模型数据如下。
>
> <img src="/Users/xiaoqiangma/Library/Application Support/typora-user-images/image-20221101174014446.png" alt="image-20221101174014446" style="zoom:50%;" />
>
> 2. 当业务告知，缺失数据视为业务下架数据时，即，缺失的数据其status会变为下架状态，此时模型数据如下。
>
> <img src="/Users/xiaoqiangma/Library/Application Support/typora-user-images/image-20221101164731727.png" alt="image-20221101164731727" style="zoom:50%;" />
>
> ​        此时模型可以看出，C产品在4-2号下架，之后再4-3号又上架

#### 结论

这两种处理做法的对比如下：

* 使用is_deleted标识的优点

  * 模型中能更详细的记录同步的信息，如is_deleted标识数据的丢失。

* 不使用is_deleted标识的优点

  * 模型中已经包含了具体的业务信息，该数据可以直接使用。而有is_deleted标识时，如果要获取已经下架的数据，则必须要知道is_deleted的业务含义才能具体获取。导致模型的使用成本增加。可以结合上述示例。

    * 没有is_deleted的标识模型中，获取当前上架的产品逻辑，filter `is_valid=1 and status=1` 即可。

    * 有is_deleted的标识模型中，获取当前上架的产品逻辑，先filter `is_valid=1 and status=1`，再需要了解is_deleted的业务场景，来决定是否需要再filter`is_deleted=0`的场景。

上述对比可以看出，在业务信息清晰的前提下，这两种建模方式都可以满足需求。不同点在于模型的使用成本。

【个人建议】数据同步（全量/增量）方式的不同不应当影响建模。即，所有的维度表中，如果既有全量又有增量更新，且全量中缺失数据的业务含义又不同，那么会导致不同表的使用方式不同，导致成本变高。而is_deleted标识的优点（保留同步信息）可以通过ods层的批次数据来记录，无需在模型中记录。因此，推荐不使用is_deleted标识。

这里还有一点需要关注。对于BA来说，不论建模是否使用is_deleted，在全量更新场景中，如果出现数据缺失，都需要有意识的了解缺失数据的业务含义。

### 2. 事实表中使用维度表的zip_id

先说结论：事实表中关联维度表zip_id目的是为了确保数据的**一致性**。同时，模型中可以直观的维护更多的业务信息。

当事实表不使用zip_id时而只是用code时，模型中就不会暴露出对应的一些问题。如下示例。

<img src="/Users/xiaoqiangma/Library/Application Support/typora-user-images/image-20221101171745308.png" alt="image-20221101171745308" style="zoom:50%;" />

<img src="/Users/xiaoqiangma/Library/Application Support/typora-user-images/image-20221101170943807.png" alt="image-20221101170943807" style="zoom:50%;" />

上图是数据平台获取的现有的订单表和产品表。此时可以看出，部分订单所涉及的产品和产品表中的数据并不一致，如。

* 产品表中A产品有效时间是从4-1日开始，但是在3-1日XXX订单中却已经存在。
* 产品表中D产品目前还没有，但是订单表中有D产品相关的订单。

首先该数据已经是数据不一致的体现。如，做订单统计时，D数据是否需要参与统计？当然，这个答案不一定，如果是维度数据更新延迟，那应该统计；但如果是订单数据错误，那就不应当参与统计。因此，需要通过关联zip_id来发现这些问题，从而确保数据一致性。因为造成这种问题的原因很多：

* 业务流程问题，如该产品还未入库就售卖
* 业务系统bug问题，该订单的产品code可能会异常
* 维度数据更新延迟
* ...

造成数据不一致的原因很多，而是用zip_id的目的就是要发现上述问题，并通过其他途径确保其数据的一致性。对于关联不上的数据，使用其他标识标记。如下图所示。

<img src="/Users/xiaoqiangma/Library/Application Support/typora-user-images/image-20221101173008759.png" alt="image-20221101173008759" style="zoom:50%;" />

该示例中，所有-1的数据均为异常数据，这样仅仅通过该模型就可以发现数据不一致的数据问题。

那么，对于-1的问题处理则是另一回事儿，如推进业务优化业务流程、修改系统bug、解决迟到维等处理方式。

##### 补充

有一种情况是否需要维护zip_id需要考虑。当事实表中的数据，其时间并非具体的时间点，而是一个时间段时，理论上是无法进行zip_id的关联。如某年的销售target数据，如果该模型视为事实表，那么其销售的zip_id则无法获取到，因为事实表的数据并非具体某一个时间点的数据。

![image-20221102144030509](/Users/xiaoqiangma/Library/Application Support/typora-user-images/image-20221102144030509.png)

### 3. 维度表中的start_time、end_time应当使用业务时间

在维度渐变表中，其start_time和end_time应当使用其业务时间，当然，有些数据没有业务时间，那此时可以将同步或执行时间作为其业务时间。

当有业务时间时，其第一次出现的数据，应当使用其业务create_time时间，而后续更新的时间应当使用update_time时间。如下示例。

<img src="/Users/xiaoqiangma/Library/Application Support/typora-user-images/image-20221101181545948.png" alt="image-20221101181545948" style="zoom:50%;" />

示例为4-1号的增量更新的数据，如果A产品为新创建的产品，那么其模型中的start_time应当是create_time而非update_time。否则在10点到19点期间的事实表将关联不到其产品zip_id。

### 4. 订单明细中不应保留订单总数字段

我们建议，在事实表中，其对应的度量值都应当是其粒度的度量信息。如下图所示。

<img src="/Users/xiaoqiangma/Library/Application Support/typora-user-images/image-20221101182401303.png" alt="image-20221101182401303" style="zoom:50%;" />

图中的订单明细表中，order_sum度量信息为订单粒度而非订单明细。

按照我们的大原则：在使用模型时，期望模型的使用尽可能少的有更多的业务上下文，且不同模型的使用方式一致。那么在对该订单明细表进行汇总时，就需要知道order_sum(额外的业务上下文)不能被基于订单进行汇总，否则数据会异常。

### 5. 日志驱动

日志驱动的核心思想在于指导ETL所需要处理的批次数据如何进行切分，即每个批次是按照怎么样的方式进行切分，而切分的逻辑需要依赖于ETL的处理日志。

常规的ETL处理调度的逻辑和带有日志驱动的逻辑区别如下图。

![image-20221102120432902](/Users/xiaoqiangma/Library/Application Support/typora-user-images/image-20221102120432902.png)

上图中将所有ETL的日志表放到了一张表中。目前抽象出的日志驱动的场景有以下几种：

* 基于时间窗口

  range_type为time_window_*的日志为基于时间窗口的日志驱动抽象。

  > log_id为1的数据代表从上一层获取财务数据的记录，每批次的粒度是天，该条日志获取的是2020-10-01更新的财务数据
  >
  > log_id为2的数据代表从上一层获取目标数据的记录，每批次的粒度是4小时，该条日志获取的是2020-10-01 0点到4点更新的目标数据

* 基于文件名称

  range_type为file_name的日志为基于文件名称的日志驱动抽象。

  > log_id为3的数据代表从上一层获取订单数据的记录，每批次的粒度是一个文件，该条日志获取的是文件名为order_20221001.xlsx的文件数据

* 基于offset

  range_type为offset的日志为基于offset的日志驱动抽象。含义为其获取的数据依赖于调度的时间，每次执行时，从上一层获取上次执行的offset到现在未处理的数据，并记录本次的offset数据。

  > log_id为4的数据代表从上一层获取浏览记录数据的记录，每批次的粒度是截止目前未同步的数据，该日志获取的数据是上一次截止到offset为9527的数据
  >
  > 可以对比log_id为5的数据，该日志记录了offset从9527到9580的数据。

  基于offset的日志驱动抽象，需要要求上一层的数据源有offset的标识来记录数据的唯一性，如消息队列的offset，或数据库的物理自增列。

* 基于上一层依赖

  range_type为depend_stream的日志为基于上一层依赖的日志驱动抽象。

  > log_id为6的数据代表从ods层获取订单数据的记录，每批次的粒度是上一层执行成功的数据，该条日志获取的是log_id为3的ods层已经处理成功的订单数据。

### 6. load的几种场景

load指的是ETL中的L，即，ETL处理的每批次的数据如何和当前current进行合并，目前有三种方式：

* **基于逻辑主键**

  通常增量更新只能使用基于逻辑主键load的场景，且current如果要做渐变（拉链），那么一定需要基于逻辑主键load的场景实现。

* **基于时间窗口的delete+insert**

  这种场景经常是上游系统提供了部分时间段的数据，该时间段是业务时间，而非更新时间。

  >  **示例**
  >
  > 上游系统每天会提供当月的订单数据，此时处理完每个月的数据后，load到current表时，处理做法就是会把该月的数据delete+insert。

  基于时间窗口的load方式，其粒度相对会粗一些，这样做不会关心该时间窗口内数据的丢失、新增或更新。

  **适用场景**：上游系统是基于业务时间段提供数据，且模型不做渐变。

* **全量truncate+insert**

  这种场景可以认为是基于时间窗口的特例，即全部业务时间的数据。

### 7. 建模和数据处理中需要考虑哪些核心因素？

前面介绍了建模的推荐方法论，如下：

* 维度表渐变，会有多余的四列
* 事实表的维度信息使用zip_id进行关联
* start_time和end_time使用业务时间
* 模型中的度量信息尽可能的和其模型粒度保持一致

那么我们在真正接入数据是，需要考虑的因素有哪些：

* 数据源的全量、增量更新
* 模型（特指事实表）是否做渐变
* load是基于哪种场景
* 每层的驱动是基于什么抽象

* 确认逻辑主键



----

产品的target
product_code, year, volume

逻辑主键？
1.product_code, year
2.product_code
==> 事实表的粒度，逻辑主键是需要包含时间相关的东西


是否渐变
a.渐变
b.非渐变

load的方式
x.基于逻辑主键
y.基于时间窗口



1 + 







